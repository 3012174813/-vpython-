def 计算结合能(原子序数):
    轨道列表 = [(n, l) for n in range(1, 8) for l in range(n)]
    轨道列表.sort(key=lambda x: (x[0] + x[1], x[0]))
    
    电子排布 = {}
    已填充电子数 = 0
    for 轨道 in 轨道列表:
        最大容量 = 2 * (2 * 轨道[1] + 1)
        可填充数 = min(最大容量, 原子序数 - 已填充电子数)
        if 可填充数 <= 0:
            break
        电子排布[轨道] = 可填充数
        已填充电子数 += 可填充数

    分组字典 = {}
    for (主量子数, 角量子数), 电子数 in 电子排布.items():
        组标识 = (主量子数, 'sp' if 角量子数 in [0, 1] else 角量子数)
        分组字典[组标识] = 分组字典.get(组标识, 0) + 电子数

    已排序组 = sorted(分组字典.keys(), key=lambda x: x[0])

    结合能列表 = []
    for 组 in 已排序组:
        电子数 = 分组字典[组]
        主量子数, _ = 组
        组索引 = 已排序组.index(组)
        内层电子数 = sum(分组字典[组] for 组 in 已排序组[:组索引])
        同组屏蔽 = (电子数 - 1) * (0.30 if 组 == (1, 'sp') else 0.35)
        σ = 内层电子数 + 同组屏蔽
        Z_eff = 原子序数 - σ
        结合能 = -13.6 * (Z_eff ** 2) / (主量子数 ** 2)
        结合能列表.extend([结合能] * 电子数)
    
    return 电子排布, 结合能列表

原子序数 = 55
电子排布, 结合能数据 = 计算结合能(原子序数)
print("电子排布详情:")
for 轨道, 数量 in sorted(电子排布.items()):
    n, l = 轨道
    print(f"{n}{'spdf'[l]}轨道：{数量}电子")

print(结合能数据)
